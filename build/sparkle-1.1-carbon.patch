
This patch makes it possible (or at any rate, easier) to use Sparkle from
Carbon applications. The original tarball is available at 

   http://sparkle.downtowncode.com/SparkleForCarbon.html

This patch contains only differences between it and upstream Sparkle.


diff -rNu Extras/Source/Sparkle.xcodeproj/project.pbxproj Extras/Source/Sparkle.xcodeproj/project.pbxproj
--- Extras/Source/Sparkle.xcodeproj/project.pbxproj	2006-07-14 04:08:05.000000000 +0200
+++ Extras/Source/Sparkle.xcodeproj/project.pbxproj	2007-03-23 23:46:54.000000000 +0100
@@ -9,6 +9,10 @@
 /* Begin PBXBuildFile section */
 		345AF9E40A5D707200D7DA6F /* SUStatusChecker.h in Headers */ = {isa = PBXBuildFile; fileRef = 345AF9E20A5D707200D7DA6F /* SUStatusChecker.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		345AF9E50A5D707200D7DA6F /* SUStatusChecker.m in Sources */ = {isa = PBXBuildFile; fileRef = 345AF9E30A5D707200D7DA6F /* SUStatusChecker.m */; };
+		5CFB98550B91393200491EB2 /* SUCarbonUpdater.h in Headers */ = {isa = PBXBuildFile; fileRef = 5CFB98530B91393200491EB2 /* SUCarbonUpdater.h */; settings = {ATTRIBUTES = (Public, ); }; };
+		5CFB98560B91393200491EB2 /* SUCarbonUpdater.m in Sources */ = {isa = PBXBuildFile; fileRef = 5CFB98540B91393200491EB2 /* SUCarbonUpdater.m */; };
+		5CFB985B0B91399200491EB2 /* Carbon.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 5CFB985A0B91399200491EB2 /* Carbon.framework */; };
+		5CFB9B0E0B91B7BB00491EB2 /* SUCarbonAPI.h in Headers */ = {isa = PBXBuildFile; fileRef = 5CFB9B0D0B91B7BB00491EB2 /* SUCarbonAPI.h */; settings = {ATTRIBUTES = (Public, ); }; };
 		610D5A1A0A1661B8004AAD9C /* Sparkle.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 8DC2EF5B0486A6940098B216 /* Sparkle.framework */; };
 		610D5A750A1670A4004AAD9C /* SUStatus.nib in Resources */ = {isa = PBXBuildFile; fileRef = 610D5A740A1670A4004AAD9C /* SUStatus.nib */; };
 		6120721209CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.h in Headers */ = {isa = PBXBuildFile; fileRef = 6120721009CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.h */; settings = {ATTRIBUTES = (Public, ); }; };
@@ -86,6 +90,10 @@
 		32DBCF5E0370ADEE00C91783 /* Sparkle_Prefix.pch */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Sparkle_Prefix.pch; sourceTree = "<group>"; };
 		345AF9E20A5D707200D7DA6F /* SUStatusChecker.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SUStatusChecker.h; sourceTree = "<group>"; };
 		345AF9E30A5D707200D7DA6F /* SUStatusChecker.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SUStatusChecker.m; sourceTree = "<group>"; };
+		5CFB98530B91393200491EB2 /* SUCarbonUpdater.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = SUCarbonUpdater.h; sourceTree = "<group>"; };
+		5CFB98540B91393200491EB2 /* SUCarbonUpdater.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = SUCarbonUpdater.m; sourceTree = "<group>"; };
+		5CFB985A0B91399200491EB2 /* Carbon.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Carbon.framework; path = /System/Library/Frameworks/Carbon.framework; sourceTree = "<absolute>"; };
+		5CFB9B0D0B91B7BB00491EB2 /* SUCarbonAPI.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SUCarbonAPI.h; sourceTree = "<group>"; };
 		610D5A740A1670A4004AAD9C /* SUStatus.nib */ = {isa = PBXFileReference; lastKnownFileType = wrapper.nib; path = SUStatus.nib; sourceTree = "<group>"; };
 		6120721009CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SUAutomaticUpdateAlert.h; sourceTree = "<group>"; };
 		6120721109CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = SUAutomaticUpdateAlert.m; sourceTree = "<group>"; };
@@ -189,7 +197,7 @@
 		61B5F8E409C4CE3C00B25A18 /* SUUpdater.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = SUUpdater.m; sourceTree = "<group>"; };
 		61B5F8E509C4CE3C00B25A18 /* NSFileManager+Authentication.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; path = "NSFileManager+Authentication.m"; sourceTree = "<group>"; };
 		61B5F8F609C4CEB300B25A18 /* Security.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Security.framework; path = /System/Library/Frameworks/Security.framework; sourceTree = "<absolute>"; };
-		61B5F90209C4CEE200B25A18 /* Sparkle Test App.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = "Sparkle Test App.app"; sourceTree = BUILT_PRODUCTS_DIR; };
+		61B5F90209C4CEE200B25A18 /* Sparkle Test App.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = "Sparkle Test App.app"; sourceTree = BUILT_PRODUCTS_DIR; };
 		61B5F90409C4CEE200B25A18 /* Test Application-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; name = "Test Application-Info.plist"; path = "Test Application/Test Application-Info.plist"; sourceTree = "<group>"; };
 		61B5F92409C4CFC900B25A18 /* main.m */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.objc; name = main.m; path = "Test Application/main.m"; sourceTree = "<group>"; };
 		61B5F92B09C4CFD800B25A18 /* English */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = text.plist.strings; name = English; path = "Test Application/English.lproj/InfoPlist.strings"; sourceTree = "<group>"; };
@@ -226,6 +234,7 @@
 				8DC2EF570486A6940098B216 /* Cocoa.framework in Frameworks */,
 				61B5F8F709C4CEB300B25A18 /* Security.framework in Frameworks */,
 				61B5FC4C09C4FD5E00B25A18 /* WebKit.framework in Frameworks */,
+				5CFB985B0B91399200491EB2 /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -285,6 +294,9 @@
 				61299A8C09CA790200B7442F /* SUUnarchiver.m */,
 				345AF9E20A5D707200D7DA6F /* SUStatusChecker.h */,
 				345AF9E30A5D707200D7DA6F /* SUStatusChecker.m */,
+				5CFB9B0D0B91B7BB00491EB2 /* SUCarbonAPI.h */,
+				5CFB98530B91393200491EB2 /* SUCarbonUpdater.h */,
+				5CFB98540B91393200491EB2 /* SUCarbonUpdater.m */,
 			);
 			name = "Sparkle Classes";
 			sourceTree = "<group>";
@@ -295,6 +307,7 @@
 				61B5FC3F09C4FD4000B25A18 /* WebKit.framework */,
 				61B5F8F609C4CEB300B25A18 /* Security.framework */,
 				1058C7B1FEA5585E11CA2CBB /* Cocoa.framework */,
+				5CFB985A0B91399200491EB2 /* Carbon.framework */,
 			);
 			name = "Linked Frameworks";
 			sourceTree = "<group>";
@@ -412,6 +425,8 @@
 				61299B3609CB04E000B7442F /* Sparkle.h in Headers */,
 				6120721209CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.h in Headers */,
 				345AF9E40A5D707200D7DA6F /* SUStatusChecker.h in Headers */,
+				5CFB98550B91393200491EB2 /* SUCarbonUpdater.h in Headers */,
+				5CFB9B0E0B91B7BB00491EB2 /* SUCarbonAPI.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -559,6 +574,7 @@
 				61299A8E09CA790200B7442F /* SUUnarchiver.m in Sources */,
 				6120721309CC5C4B007FE0F6 /* SUAutomaticUpdateAlert.m in Sources */,
 				345AF9E50A5D707200D7DA6F /* SUStatusChecker.m in Sources */,
+				5CFB98560B91393200491EB2 /* SUCarbonUpdater.m in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
diff -rNu Extras/Source/SUAppcast.h Extras/Source/SUAppcast.h
--- Extras/Source/SUAppcast.h	2006-03-17 16:07:05.000000000 +0100
+++ Extras/Source/SUAppcast.h	2007-02-25 04:14:12.000000000 +0100
@@ -24,4 +24,5 @@
 
 @interface NSObject (SUAppcastDelegate)
 - appcastDidFinishLoading:(SUAppcast *)appcast;
+- appcastDidFailToLoad:(SUAppcast *)appcast;
 @end
\ No newline at end of file
diff -rNu Extras/Source/SUAppcastItem.h Extras/Source/SUAppcastItem.h
--- Extras/Source/SUAppcastItem.h	2006-06-06 00:33:47.000000000 +0200
+++ Extras/Source/SUAppcastItem.h	2007-02-24 02:35:12.000000000 +0100
@@ -19,6 +19,8 @@
 	NSString *DSASignature;
 	NSString *MD5Sum;
 	
+	NSString *minimumSystemVersion;
+	
 	NSURL *fileURL;
 	NSString *fileVersion;
 	NSString *versionString;
@@ -54,4 +56,7 @@
 - (NSString *)versionString;
 - (void)setVersionString:(NSString *)versionString;
 
+- (NSString *)minimumSystemVersion;
+- (void)setMinimumSystemVersion:(NSString *)systemVersionString;
+
 @end
diff -rNu Extras/Source/SUAppcastItem.m Extras/Source/SUAppcastItem.m
--- Extras/Source/SUAppcastItem.m	2006-06-06 00:33:47.000000000 +0200
+++ Extras/Source/SUAppcastItem.m	2007-02-24 02:35:12.000000000 +0100
@@ -38,6 +38,12 @@
 		[self setReleaseNotesURL:nil];
 	}
 	
+	NSString *minVersion = [dict objectForKey:@"sparkle:minimumSystemVersion"];
+	if(minVersion)
+		[self setMinimumSystemVersion:minVersion];
+	else
+		[self setMinimumSystemVersion:@"10.3.0"];//sparkle doesn't run on 10.2-, so we don't have to worry about it
+	
 	// Try to find a version string.
 	// Finding the new version number from the RSS feed is a little bit hacky. There are two ways:
 	// 1. A "sparkle:version" attribute on the enclosure tag, an extension from the RSS spec.
@@ -153,6 +159,15 @@
 }
 
 
+- (NSString *)minimumSystemVersion { return [[minimumSystemVersion retain] autorelease]; }
+- (void)setMinimumSystemVersion:(NSString *)systemVersionString
+{
+	if(minimumSystemVersion)
+		[minimumSystemVersion autorelease];
+	minimumSystemVersion = systemVersionString;
+}
+
+
 - (void)dealloc
 {
     [self setTitle:nil];
diff -rNu Extras/Source/SUCarbonAPI.h Extras/Source/SUCarbonAPI.h
--- Extras/Source/SUCarbonAPI.h	1970-01-01 01:00:00.000000000 +0100
+++ Extras/Source/SUCarbonAPI.h	2007-03-23 23:35:58.000000000 +0100
@@ -0,0 +1,53 @@
+/*
+ *  SUCarbonAPI.h
+ *  Sparkle
+ *
+ *  Created by Jack Small on 2/22/07.
+ *  Copyright 2007 Jack Small. All rights reserved.
+ *
+ */
+
+#ifndef SUCARBONAPI
+#define SUCARBONAPI
+
+#include <Carbon/Carbon.h>
+
+#if PRAGMA_ONCE
+#pragma once
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+enum {
+	/* This HICommand is handeled automatically by Sparkle and calls SUSparkleCheckForUpdates( TRUE ); */
+	kHICommandSparkleCheckForUpdates = 'sCUP',
+	
+	/* This HICommand is sent to the application by Sparkle before kHICommandQuit.  If your event
+	   handler returns noErr the kHICommandQuit command is not sent.  */
+	kHICommandSparkleQuitApplication = 'sQAP'
+};
+
+enum {
+	kEventClassSparkle = 'Sprk'
+};
+
+enum {
+	kEventSparkleFoundVersion = 1,
+	kEventParamSparkleVersion = 'sVrs',		/* typeCFStringRef (optional) */
+	kEventParamSparkleIsNew = 'sNew'		/* typeBoolean */
+}; 
+
+void SUSparkleInitializeForCarbon( void );
+void SUSparkleCheckForUpdates( Boolean showUI );
+void SUSparkleCheckWithInterval( double interval );
+void SUSparkleCheckStatus( EventTargetRef theEventTarget );
+Boolean SUSparkleIsUpdateInProgress( void );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SUCARBONAPI */
+
diff -rNu Extras/Source/SUCarbonUpdater.h Extras/Source/SUCarbonUpdater.h
--- Extras/Source/SUCarbonUpdater.h	1970-01-01 01:00:00.000000000 +0100
+++ Extras/Source/SUCarbonUpdater.h	2007-02-25 13:40:38.000000000 +0100
@@ -0,0 +1,34 @@
+//
+//  SUCarbonUpdater.h
+//  Sparkle
+//
+//  Created by Jack Small on 2/22/07.
+//  Copyright 2007 Jack Small. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+#import "SUUpdater.h"
+#import "SUCarbonAPI.h"
+
+@interface SUCarbonUpdater : SUUpdater {
+	EventTargetRef	carbonEventTarget;
+}
+
+// This method creates a new updater and simulates the "applicationDidFinishLaunchingNotification".
+// It is most likely that a Carbon app has already finished launching when Sparkle initilaization
+// occurs.  It is called by SUSparkleInitializeForCarbon().  
++ (SUCarbonUpdater*)updaterForCarbon;
+
+// This method creates a new status checker and sets the event target.  If statusEventTarget is
+// NULL then GetApplicationEventTarget() is used instead.  It is called by SUSparkleCheckStatus().
++ (SUCarbonUpdater*)statusCheckerForCarbon:(EventTargetRef)statusEventTarget;
+
+// This utility method was added for Carbon applications to check if updates are running.
+// It is called by SUSparkleIsUpdateInProgress().
+- (BOOL)updateInProgress;
+
+// This method changes the event target for this updater.  If set, a kEventSparkleFoundVersion
+// event is sent when an appcast result is found, instead of a traditinal install.
+- (id)setCarbonEventTarget:(EventTargetRef)statusEventTarget;
+
+@end
diff -rNu Extras/Source/SUCarbonUpdater.m Extras/Source/SUCarbonUpdater.m
--- Extras/Source/SUCarbonUpdater.m	1970-01-01 01:00:00.000000000 +0100
+++ Extras/Source/SUCarbonUpdater.m	2007-02-25 13:22:38.000000000 +0100
@@ -0,0 +1,239 @@
+//
+//  SUCarbonUpdater.m
+//  Sparkle
+//
+//  Created by Jack Small on 2/22/07.
+//  Copyright 2007 Jack Small. All rights reserved.
+//
+
+#import "SUCarbonUpdater.h"
+#import "SUAppcast.h"
+#import "SUAppcastItem.h"
+
+#import <Carbon/Carbon.h>
+
+id	g_SharedSUUpdater = nil;
+
+static  OSStatus  _SparkleEventHandler( EventHandlerCallRef inCallRef, EventRef inEvent, void *inUserData );
+static  OSStatus  _SparkleEventHandler( EventHandlerCallRef inCallRef, EventRef inEvent, void *inUserData )
+{
+	#pragma unused ( inCallRef, inUserData )
+	HICommand	command;
+	OSStatus	err			= eventNotHandledErr;
+	UInt32		eventClass	= GetEventClass( inEvent );
+	UInt32		eventKind	= GetEventKind( inEvent );
+  
+	if( ( eventClass == kEventClassCommand ) && ( eventKind == kEventCommandUpdateStatus ) )
+	{
+		GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &command );
+		if ( command.commandID == kHICommandSparkleCheckForUpdates )
+		{
+			if( command.attributes & kHICommandFromMenu )
+			{
+				if( SUSparkleIsUpdateInProgress() ) DisableMenuItem( command.menu.menuRef, command.menu.menuItemIndex );
+				else EnableMenuItem( command.menu.menuRef, command.menu.menuItemIndex );
+			}
+			err  = noErr;
+		}	
+	}
+
+	if( ( eventClass == kEventClassCommand ) && ( eventKind == kEventCommandProcess ) )
+	{
+		GetEventParameter( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof(HICommand), NULL, &command );
+		if ( command.commandID == kHICommandSparkleCheckForUpdates )
+		{
+			SUSparkleCheckForUpdates( TRUE );
+			err  = noErr;
+		}
+	}
+
+	return( err );
+}
+
+void SUSparkleInitializeForCarbon( void )
+{
+	NSAutoreleasePool*	aPool;
+    const  EventTypeSpec  applicationEvents[] =	{	{ kEventClassCommand, kEventCommandProcess },
+													{ kEventClassCommand, kEventCommandUpdateStatus }
+												};
+	if( g_SharedSUUpdater == nil )
+	{
+		InstallApplicationEventHandler( NewEventHandlerUPP(_SparkleEventHandler), GetEventTypeCount(applicationEvents), applicationEvents, 0, NULL );
+
+		NSApplicationLoad();
+
+		aPool = [[NSAutoreleasePool alloc] init];
+		g_SharedSUUpdater = [SUCarbonUpdater updaterForCarbon];	
+		[aPool release];
+	}
+}
+
+void SUSparkleCheckForUpdates( Boolean showUI )
+{
+	NSAutoreleasePool*	aPool;
+
+	if( g_SharedSUUpdater != nil ) {
+		aPool = [[NSAutoreleasePool alloc] init];
+		if( showUI ) [g_SharedSUUpdater checkForUpdates:nil];
+		else [g_SharedSUUpdater checkForUpdatesInBackground];
+		[aPool release];
+	}
+}
+
+void SUSparkleCheckWithInterval( double interval )
+{
+	NSAutoreleasePool*	aPool;
+
+	if( g_SharedSUUpdater != nil ) {
+		aPool = [[NSAutoreleasePool alloc] init];
+		[g_SharedSUUpdater scheduleCheckWithInterval:interval];
+		[aPool release];
+	}
+}
+
+void SUSparkleCheckStatus( EventTargetRef theEventTarget )
+{
+	NSAutoreleasePool*	aPool = [[NSAutoreleasePool alloc] init];
+	EventTargetRef		aTarget = theEventTarget;
+	id					updater;
+	
+	if( aTarget == NULL ) aTarget = GetApplicationEventTarget();
+	updater = [SUCarbonUpdater statusCheckerForCarbon:aTarget];	
+
+	[aPool release];
+}
+
+Boolean SUSparkleIsUpdateInProgress( void )
+{
+	if( g_SharedSUUpdater != nil ) return [g_SharedSUUpdater updateInProgress];
+	else return FALSE;
+}
+
+@interface SUCarbonUpdater (Private)
+- (void)doQuitApplication;
+- (BOOL)newVersionAvailable;
+- (void)foundVersion:(NSString *)versionString isNewVersion:(BOOL)isNewVersion;
+@end;
+
+@implementation SUCarbonUpdater
+
+// A Carbon application initialized via SUSparkleInitializeForCarbon() will make that call after the application
+// has finished launching, thus missing NSApplicationDidFinishLaunchingNotification.  
++ (SUCarbonUpdater*)updaterForCarbon
+{
+	SUCarbonUpdater*	updater = [[self alloc] init];
+	
+	[updater applicationDidFinishLaunching:nil];
+
+	return updater;
+}
+
++ (SUCarbonUpdater*)statusCheckerForCarbon:(EventTargetRef)statusEventTarget
+{
+	SUCarbonUpdater*	updater = [[[self alloc] init] setCarbonEventTarget:statusEventTarget];
+	
+	[updater checkForUpdatesInBackground];
+
+	return updater;
+}
+
+- (id)setCarbonEventTarget:(EventTargetRef)statusEventTarget
+{
+	carbonEventTarget = statusEventTarget;
+	return self;
+}
+
+- (BOOL)updateInProgress
+{
+	return updateInProgress;
+}
+
+- (void)appcastDidFailToLoad:(SUAppcast *)ac
+{
+	if( carbonEventTarget == NULL ) [super appcastDidFailToLoad:ac];
+	else [self appcastDidFinishLoading:ac];
+}
+
+- (void)appcastDidFinishLoading:(SUAppcast *)ac
+{
+	if( carbonEventTarget == NULL ) [super appcastDidFinishLoading:ac];
+	else {
+		@try
+		{
+			if (!ac) { [NSException raise:@"SUAppcastException" format:@"Couldn't get a valid appcast from the server."]; }
+			
+			updateItem = [[ac newestItem] retain];
+			[ac autorelease];
+			
+			if (![updateItem fileVersion])
+			{
+				[NSException raise:@"SUAppcastException" format:@"Can't extract a version string from the appcast feed. The filenames should look like YourApp_1.5.tgz, where 1.5 is the version number."];
+			}
+
+			[self foundVersion:[updateItem fileVersion]
+				 isNewVersion:[self newVersionAvailable]];
+		}
+		@catch (NSException *e)
+		{
+			NSLog([e reason]);
+
+			[self foundVersion:nil isNewVersion:NO];
+		}
+
+		updateInProgress = NO;
+		
+		[self release];		//	Updaters with carbonEventTargets are one shot instances and this is the end of the line.
+	}
+}
+
+- (void)foundVersion:(NSString *)versionString isNewVersion:(BOOL)isNewVersion
+{
+	EventRef	theEvent;
+	
+	if( carbonEventTarget != NULL )
+	{
+		CreateEvent( kCFAllocatorDefault, kEventClassSparkle, kEventSparkleFoundVersion, 0, kEventAttributeUserEvent, &theEvent );
+		SetEventParameter( theEvent, kEventParamPostTarget, typeEventTargetRef, sizeof(typeEventTargetRef), &carbonEventTarget );
+		if( versionString != NULL ) SetEventParameter( theEvent, kEventParamSparkleVersion, typeCFStringRef, sizeof(CFStringRef), &versionString );
+		SetEventParameter( theEvent, kEventParamSparkleIsNew, typeBoolean, sizeof(Boolean), &isNewVersion );
+
+		PostEventToQueue( GetCurrentEventQueue(), theEvent, kEventPriorityStandard );
+				
+		ReleaseEvent( theEvent );
+	}
+}
+
+- (void)doQuitApplication
+{
+	// Slightly different quit mechanism for Carbon applications.
+	OSStatus	quitResult = eventNotHandledErr;
+	HICommand	quitCommand = { kEventAttributeNone, kHICommandSparkleQuitApplication };
+	
+	// First send custom Sparkle HICommand
+	quitResult = ProcessHICommand( &quitCommand );
+	
+	// Second try regular Quit HICommand
+	if( quitResult != noErr )
+	{
+		quitCommand.commandID = kHICommandQuit;
+		quitResult = ProcessHICommand( &quitCommand );
+	}
+
+	// Third try using Core Foundation
+	if( quitResult != noErr )
+	{
+		CFRunLoopRef	thisLoop = CFRunLoopGetCurrent();
+		CFStringRef		thisMode = CFRunLoopCopyCurrentMode(thisLoop);
+		if(  thisMode != NULL )
+		{
+			CFRelease( thisMode );
+			CFRunLoopStop( thisLoop );
+			quitResult = noErr;
+		}
+	}
+
+	// Finally just bail
+	if( quitResult != noErr ) ExitToShell();
+}
+
+@end
diff -rNu Extras/Source/SUUpdater.h Extras/Source/SUUpdater.h
--- Extras/Source/SUUpdater.h	2006-03-17 16:07:05.000000000 +0100
+++ Extras/Source/SUUpdater.h	2007-02-25 11:52:58.000000000 +0100
@@ -33,6 +33,8 @@
 	
 	BOOL verbose;
 	BOOL updateInProgress;
+	
+	NSString *currentSystemVersion;
 }
 
 // This IBAction is meant for a main menu item. Hook up any menu item to this action,
diff -rNu Extras/Source/SUUpdater.m Extras/Source/SUUpdater.m
--- Extras/Source/SUUpdater.m	2006-07-14 04:08:05.000000000 +0200
+++ Extras/Source/SUUpdater.m	2007-02-25 10:45:16.000000000 +0100
@@ -40,6 +40,13 @@
 {
 	[super init];
 	[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationDidFinishLaunching:) name:@"NSApplicationDidFinishLaunchingNotification" object:NSApp];	
+	
+	// OS version (Apple recommends using SystemVersion.plist instead of Gestalt() here, don't ask me why).
+	// This code *should* use NSSearchPathForDirectoriesInDomains(NSCoreServiceDirectory, NSSystemDomainMask, YES)
+	// but that returns /Library/CoreServices for some reason
+	NSString *versionPlistPath = @"/System/Library/CoreServices/SystemVersion.plist";
+	//gets a version string of the form X.Y.Z
+	currentSystemVersion = [[[NSDictionary dictionaryWithContentsOfFile:versionPlistPath] objectForKey:@"ProductVersion"] retain];
 	return self;
 }
 
@@ -119,6 +126,9 @@
 	if (checkTimer)
 		[checkTimer invalidate];
 	
+	if (currentSystemVersion)
+		[currentSystemVersion release];
+	
 	[[NSNotificationCenter defaultCenter] removeObserver:self];
 	[super dealloc];
 }
@@ -180,7 +190,7 @@
 - (void)showUpdateErrorAlertWithInfo:(NSString *)info
 {
 	if ([self isAutomaticallyUpdating]) { return; }
-	NSRunAlertPanel(SULocalizedString(@"Update Error!", nil), info, NSLocalizedString(@"Cancel", nil), nil, nil);
+	NSRunAlertPanel(SULocalizedString(@"Update Error!", nil), info, SULocalizedString(@"Cancel", nil), nil, nil);
 }
 
 - (NSTimeInterval)storedCheckInterval
@@ -203,7 +213,7 @@
 	{
 		statusController = [[SUStatusController alloc] init];
 		[statusController beginActionWithTitle:SULocalizedString(@"Downloading update...", nil) maxProgressValue:0 statusText:nil];
-		[statusController setButtonTitle:NSLocalizedString(@"Cancel", nil) target:self action:@selector(cancelDownload:) isDefault:NO];
+		[statusController setButtonTitle:SULocalizedString(@"Cancel", nil) target:self action:@selector(cancelDownload:) isDefault:NO];
 		[statusController showWindow:self];
 	}
 	
@@ -265,7 +275,8 @@
 // Override this to change the new version comparison logic!
 - (BOOL)newVersionAvailable
 {
-	return SUStandardVersionComparison([updateItem fileVersion], SUHostAppVersion()) == NSOrderedAscending;
+	BOOL canRunOnCurrentSystem = SUStandardVersionComparison([updateItem minimumSystemVersion], currentSystemVersion) == NSOrderedDescending;
+	return (canRunOnCurrentSystem && (SUStandardVersionComparison([updateItem fileVersion], SUHostAppVersion()) == NSOrderedAscending));
 	// Want straight-up string comparison like Sparkle 1.0b3 and earlier? Uncomment the line below and comment the one above.
 	// return ![SUHostAppVersion() isEqualToString:[updateItem fileVersion]];
 }
@@ -310,7 +321,7 @@
 		{
 			if (verbose) // We only notify on no new version when we're being verbose.
 			{
-				NSRunAlertPanel(SULocalizedString(@"You're up to date!", nil), [NSString stringWithFormat:SULocalizedString(@"%@ %@ is currently the newest version available.", nil), SUHostAppDisplayName(), SUHostAppVersionString()], NSLocalizedString(@"OK", nil), nil, nil);
+				NSRunAlertPanel(SULocalizedString(@"You're up to date!", nil), [NSString stringWithFormat:SULocalizedString(@"%@ %@ is currently the newest version available.", nil), SUHostAppDisplayName(), SUHostAppVersionString()], SULocalizedString(@"OK", nil), nil, nil);
 			}
 			updateInProgress = NO;
 		}
@@ -433,10 +444,12 @@
 
 - (void)abandonUpdate
 {
-	[updateItem release];
+	[updateItem autorelease];
+	updateItem = nil;
 	[statusController close];
-	[statusController release];
-	updateInProgress = NO;	
+	[statusController autorelease];
+	statusController = nil;
+	updateInProgress = NO;
 }
 
 - (void)download:(NSURLDownload *)download didFailWithError:(NSError *)error
@@ -447,10 +460,15 @@
 	[self showUpdateErrorAlertWithInfo:SULocalizedString(@"An error occurred while trying to download the file. Please try again later.", nil)];
 }
 
+- (void)doQuitApplication
+{
+	[NSApp terminate:self];	
+}
+
 - (IBAction)installAndRestart:sender
 {
 	NSString *currentAppPath = [[NSBundle mainBundle] bundlePath];
-	NSString *newAppDownloadPath = [[downloadPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:[SUInfoValueForKey(@"CFBundleName") stringByAppendingPathExtension:@"app"]];
+	NSString *newAppDownloadPath = [[downloadPath stringByDeletingLastPathComponent] stringByAppendingPathComponent:[SUUnlocalizedInfoValueForKey(@"CFBundleName") stringByAppendingPathExtension:@"app"]];
 	@try 
 	{
 		if (![self isAutomaticallyUpdating])
@@ -466,10 +484,10 @@
 		
 		// We assume that the archive will contain a file named {CFBundleName}.app
 		// (where, obviously, CFBundleName comes from Info.plist)
-		if (!SUInfoValueForKey(@"CFBundleName")) { [NSException raise:@"SUInstallException" format:@"This application has no CFBundleName! This key must be set to the application's name."]; }
+		if (!SUUnlocalizedInfoValueForKey(@"CFBundleName")) { [NSException raise:@"SUInstallException" format:@"This application has no CFBundleName! This key must be set to the application's name."]; }
 		
 		// Search subdirectories for the application
-		NSString *file, *appName = [SUInfoValueForKey(@"CFBundleName") stringByAppendingPathExtension:@"app"];
+		NSString *file, *appName = [SUUnlocalizedInfoValueForKey(@"CFBundleName") stringByAppendingPathExtension:@"app"];
 		NSDirectoryEnumerator *dirEnum = [[NSFileManager defaultManager] enumeratorAtPath:[downloadPath stringByDeletingLastPathComponent]];
 		while ((file = [dirEnum nextObject]))
 		{
@@ -538,7 +556,7 @@
 		   "  fi\n"
 		   "  rm -rf \"${TEMP_FOLDER}\"\n"
 		   "} &>/dev/null &'");
-	[NSApp terminate:self];	
+	[self doQuitApplication];
 }
 
 - (IBAction)cancelDownload:sender
diff -rNu Extras/Source/SUUtilities.h Extras/Source/SUUtilities.h
--- Extras/Source/SUUtilities.h	2006-06-21 01:46:47.000000000 +0200
+++ Extras/Source/SUUtilities.h	2007-02-24 02:35:12.000000000 +0100
@@ -9,6 +9,7 @@
 #import <Cocoa/Cocoa.h>
 
 id SUInfoValueForKey(NSString *key);
+id SUUnlocalizedInfoValueForKey(NSString *key);
 NSString *SUHostAppName();
 NSString *SUHostAppDisplayName();
 NSString *SUHostAppVersion();
diff -rNu Extras/Source/SUUtilities.m Extras/Source/SUUtilities.m
--- Extras/Source/SUUtilities.m	2006-06-21 01:46:47.000000000 +0200
+++ Extras/Source/SUUtilities.m	2007-02-24 02:35:12.000000000 +0100
@@ -12,6 +12,15 @@
 	+(NSString *)localizedStringForKey:(NSString *)key withComment:(NSString *)comment;
 @end
 
+id SUUnlocalizedInfoValueForKey(NSString *key)
+{
+	// Okay, but if it isn't there, let's use the general one.
+	id value = [[[NSBundle mainBundle] infoDictionary] valueForKey:key];
+	if (!value)
+		return SUInfoValueForKey(key);
+	return value;
+}
+
 id SUInfoValueForKey(NSString *key)
 {
 	return [[NSBundle mainBundle] objectForInfoDictionaryKey:key];
