/*
 *  This file is part of Poedit (https://poedit.net)
 *
 *  Copyright (C) 1999-2016 Vaclav Slavik
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 *
 */

#include "editing_area.h"

#include "customcontrols.h"
#include "edlistctrl.h"
#include "errorbar.h"
#include "hidpi.h"
#include "main_toolbar.h"
#include "pluralforms/pl_evaluate.h"
#include "spellchecking.h"
#include "text_control.h"
#include "utility.h"

#include <wx/button.h>
#include <wx/notebook.h>
#include <wx/sizer.h>
#include <wx/stattext.h>

#include <algorithm>


namespace
{

struct EventHandlerDisabler
{
    EventHandlerDisabler(wxEvtHandler *h) : m_hnd(h)
        { m_hnd->SetEvtHandlerEnabled(false); }
    ~EventHandlerDisabler()
        { m_hnd->SetEvtHandlerEnabled(true); }

    wxEvtHandler *m_hnd;
};

void SetTranslationValue(TranslationTextCtrl *txt, const wxString& value, int flags)
{
    // disable EVT_TEXT forwarding -- the event is generated by
    // programmatic changes to text controls' content and we *don't*
    // want UpdateFromTextCtrl() to be called from here
    EventHandlerDisabler disabler(txt->GetEventHandler());

    if (flags & EditingArea::UndoableEdit)
        txt->SetPlainTextUserWritten(value);
    else
        txt->SetPlainText(value);
}

inline void SetCtrlFont(wxWindow *win, const wxFont& font)
{
    if (!win)
        return;

#ifdef __WXMSW__
    // Native wxMSW text control sends EN_CHANGE when the font changes,
    // producing a wxEVT_TEXT event as if the user changed the value.
    // Unfortunately the event seems to be used internally for sizing,
    // so we can't just filter it out completely. What we can do, however,
    // is to disable *our* handling of the event.
    EventHandlerDisabler disabler(win->GetEventHandler());
#endif
    win->SetFont(font);
}

// does some basic processing of user input, e.g. to remove trailing \n
wxString PreprocessEnteredTextForItem(CatalogItemPtr item, wxString t)
{
    auto& orig = item->GetString();

    if (!t.empty() && !orig.empty())
    {
        if (orig.Last() == '\n' && t.Last() != '\n')
            t.append(1, '\n');
        else if (orig.Last() != '\n' && t.Last() == '\n')
            t.RemoveLast();
    }

    return t;
}

} // anonymous namespace


EditingArea::EditingArea(wxWindow *parent, PoeditListCtrl *associatedList, MainToolbar *associatedToolbar, Mode mode)
    : m_associatedList(associatedList),
      m_associatedToolbar(associatedToolbar),
      m_dontAutoclearFuzzyStatus(false),
      m_textOrig(nullptr),
      m_textOrigPlural(nullptr),
      m_textTrans(nullptr),
      m_pluralNotebook(nullptr),
      m_labelSingular(nullptr),
      m_labelPlural(nullptr),
      m_labelContext(nullptr),
      m_errorBar(nullptr)
{
    wxPanel::Create(parent, wxID_ANY, wxDefaultPosition, wxDefaultSize,
                    wxTAB_TRAVERSAL | wxNO_BORDER | wxFULL_REPAINT_ON_RESIZE);
#ifdef __WXMSW__
    SetDoubleBuffered(true);
#endif

    wxStaticText *labelSource =
        new wxStaticText(this, -1, _("Source text:"));
    labelSource->SetFont(labelSource->GetFont().Bold());

    m_labelContext = new wxStaticText(this, -1, wxEmptyString);
#ifdef __WXOSX__
    m_labelContext->SetMinSize(wxSize(-1, m_labelContext->GetBestSize().y + 3));
#endif
    m_labelContext->Hide();

    m_labelSingular = new wxStaticText(this, -1, _("Singular:"));
    m_textOrig = new SourceTextCtrl(this, wxID_ANY);
    m_labelPlural = new wxStaticText(this, -1, _("Plural:"));
    m_textOrigPlural = new SourceTextCtrl(this, wxID_ANY);

    auto *sizer = new wxBoxSizer(wxVERTICAL);
    SetSizer(sizer);

    wxFlexGridSizer *gridSizer = new wxFlexGridSizer(2);
    gridSizer->AddGrowableCol(1);
    gridSizer->AddGrowableRow(0);
    gridSizer->AddGrowableRow(1);
    gridSizer->Add(m_labelSingular, 0, wxALIGN_CENTER_VERTICAL | wxALL, 3);
    gridSizer->Add(m_textOrig, 1, wxEXPAND);
    gridSizer->Add(m_labelPlural, 0, wxALIGN_CENTER_VERTICAL | wxALL, 3);
    gridSizer->Add(m_textOrigPlural, 1, wxEXPAND);
    gridSizer->SetItemMinSize(m_textOrig, 1, 1);
    gridSizer->SetItemMinSize(m_textOrigPlural, 1, 1);

    sizer->Add(m_labelContext, 0, wxEXPAND | wxALL, 3);
    sizer->Add(labelSource, 0, wxEXPAND | wxALL, 3);
    sizer->Add(gridSizer, 1, wxEXPAND);

    if (mode == POT)
        CreateTemplateControls(sizer);
    else
        CreateEditControls(sizer);
}


void EditingArea::CreateEditControls(wxBoxSizer *sizer)
{
    wxStaticText *labelTrans = new wxStaticText(this, -1, _("Translation:"));
    labelTrans->SetFont(labelTrans->GetFont().Bold());

    m_textTrans = new TranslationTextCtrl(this, wxID_ANY);
    m_textTrans->Bind(wxEVT_TEXT, [=](wxCommandEvent& e){ e.Skip(); UpdateFromTextCtrl(); });

    // in case of plurals form, this is the control for n=1:
    m_textTransSingularForm = nullptr;

    m_pluralNotebook = new wxNotebook(this, -1, wxDefaultPosition, wxDefaultSize, wxNB_NOPAGETHEME);
    m_pluralNotebook->SetWindowVariant(wxWINDOW_VARIANT_SMALL);

    m_errorBar = new ErrorBar(this);

    sizer->Add(labelTrans, 0, wxEXPAND | wxALL, 3);
    sizer->Add(m_textTrans, 1, wxEXPAND);
    sizer->Add(m_pluralNotebook, 1, wxEXPAND);
    sizer->Add(m_errorBar, 0, wxEXPAND | wxALL, 2);

    ShowPluralFormUI(false);
}


void EditingArea::CreateTemplateControls(wxBoxSizer *panelSizer)
{
    auto win = new wxPanel(this, wxID_ANY);
    auto sizer = new wxBoxSizer(wxVERTICAL);

    auto explain = new wxStaticText(win, wxID_ANY, _(L"POT files are only templates and don’t contain any translations themselves.\nTo make a translation, create a new PO file based on the template."), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTRE_HORIZONTAL);
#ifdef __WXOSX__
    explain->SetWindowVariant(wxWINDOW_VARIANT_SMALL);
#endif
    explain->SetForegroundColour(ExplanationLabel::GetTextColor().ChangeLightness(160));
    win->SetBackgroundColour(GetBackgroundColour().ChangeLightness(50));

    auto button = new wxButton(win, XRCID("button_new_from_this_pot"), MSW_OR_OTHER(_("Create new translation"), _("Create New Translation")));

    sizer->AddStretchSpacer();
    sizer->Add(explain, wxSizerFlags().Center().Border(wxLEFT|wxRIGHT, PX(100)));
    sizer->Add(button, wxSizerFlags().Center().Border(wxTOP|wxBOTTOM, PX(10)));
    sizer->AddStretchSpacer();

    win->SetSizerAndFit(sizer);

    panelSizer->Add(win, 1, wxEXPAND);
}


void EditingArea::SetCustomFont(const wxFont& font)
{
    SetCtrlFont(m_textOrig, font);
    SetCtrlFont(m_textOrigPlural, font);
    SetCtrlFont(m_textTrans, font);
    for (auto tp : m_textTransPlural)
        SetCtrlFont(tp, font);
}


bool EditingArea::InitSpellchecker(bool enabled, Language lang)
{
    bool rv = true;

    if (m_textTrans)
    {
        if (!InitTextCtrlSpellchecker(m_textTrans, enabled, lang))
            rv = false;
    }

    for (auto tp : m_textTransPlural)
    {
        if (tp && !InitTextCtrlSpellchecker(tp, enabled, lang))
            rv = false;
    }

    return rv;
}


void EditingArea::SetLanguage(Language lang)
{
    if (m_textTrans)
        m_textTrans->SetLanguage(lang);

    for (auto tp : m_textTransPlural)
    {
        if (tp)
            tp->SetLanguage(lang);
    }
}


void EditingArea::RecreatePluralTextCtrls(CatalogPtr catalog)
{
    if (!m_pluralNotebook)
        return;

    m_textTransPlural.clear();
    m_pluralNotebook->DeleteAllPages();
    m_textTransSingularForm = NULL;

    auto calc = PluralFormsCalculator::make(catalog->Header().GetHeader("Plural-Forms").ToAscii());

    int formsCount = catalog->GetPluralFormsCount();
    for (int form = 0; form < formsCount; form++)
    {
        // find example number that would use this plural form:
        static const int maxExamplesCnt = 5;
        wxString examples;
        int firstExample = -1;
        int examplesCnt = 0;

        if (calc && formsCount > 1)
        {
            for (int example = 0; example < 1000; example++)
            {
                if (calc->evaluate(example) == form)
                {
                    if (++examplesCnt == 1)
                        firstExample = example;
                    if (examplesCnt == maxExamplesCnt)
                    {
                        examples += L'…';
                        break;
                    }
                    else if (examplesCnt == 1)
                        examples += wxString::Format("%d", example);
                    else
                        examples += wxString::Format(", %d", example);
                }
            }
        }

        wxString desc;
        if (formsCount == 1)
            desc = _("Everything");
        else if (examplesCnt == 0)
            desc.Printf(_("Form %i"), form);
        else if (examplesCnt == 1)
        {
            if (formsCount == 2 && firstExample == 1) // English-like
            {
                desc = _("Singular");
            }
            else
            {
                if (firstExample == 0)
                    desc = _("Zero");
                else if (firstExample == 1)
                    desc = _("One");
                else if (firstExample == 2)
                    desc = _("Two");
                else
                    desc.Printf(L"n = %s", examples);
            }
        }
        else if (formsCount == 2 && examplesCnt == 2 && firstExample == 0 && examples == "0, 1")
        {
            desc = _("Singular");
        }
        else if (formsCount == 2 && firstExample != 1 && examplesCnt == maxExamplesCnt)
        {
            if (firstExample == 0 || firstExample == 2)
                desc = _("Plural");
            else
                desc = _("Other");
        }
        else
            desc.Printf(L"n → %s", examples);

        // create text control and notebook page for it:
        auto txt = new TranslationTextCtrl(m_pluralNotebook, wxID_ANY);
        txt->SetWindowVariant(wxWINDOW_VARIANT_NORMAL);
#ifndef __WXOSX__
        txt->SetFont(m_textTrans->GetFont());
#endif
        txt->Bind(wxEVT_TEXT, [=](wxCommandEvent& e){ e.Skip(); UpdateFromTextCtrl(); });
        m_textTransPlural.push_back(txt);
        m_pluralNotebook->AddPage(txt, desc);

        if (examplesCnt == 1 && firstExample == 1) // == singular
            m_textTransSingularForm = txt;
    }

    // as a fallback, assume 1st form for plural entries is the singular
    // (like in English and most real-life uses):
    if (!m_textTransSingularForm && !m_textTransPlural.empty())
        m_textTransSingularForm = m_textTransPlural[0];
}


void EditingArea::ShowPluralFormUI(bool show)
{
    wxSizer *origSizer = m_textOrig->GetContainingSizer();
    origSizer->Show(m_labelSingular, show);
    origSizer->Show(m_labelPlural, show);
    origSizer->Show(m_textOrigPlural, show);
    origSizer->Layout();

    if (m_textTrans && m_pluralNotebook)
    {
        wxSizer *textSizer = m_textTrans->GetContainingSizer();
        textSizer->Show(m_textTrans, !show);
        textSizer->Show(m_pluralNotebook, show);
        textSizer->Layout();
    }
}


void EditingArea::SetSingleSelectionMode()
{
    if (!IsThisEnabled())
        Enable();  // in case of previous multiple selection
}


void EditingArea::SetMultipleSelectionMode()
{
    // TODO: Show better UI
    Disable();
}


void EditingArea::SetTextFocus()
{
    if (m_textTrans && m_textTrans->IsShown())
        m_textTrans->SetFocus();
    else if (!m_textTransPlural.empty())
        m_textTransPlural[0]->SetFocus();
}

bool EditingArea::HasTextFocus()
{
    wxWindow *focus = wxWindow::FindFocus();
    return (focus == m_textTrans) ||
           (focus && focus->GetParent() == m_pluralNotebook);
}

bool EditingArea::HasTextFocusInPlurals()
{
    if (!m_pluralNotebook || !m_pluralNotebook->IsShown())
        return false;

    auto focused = dynamic_cast<TranslationTextCtrl*>(FindFocus());
    if (!focused)
        return false;

    return std::find(m_textTransPlural.begin(), m_textTransPlural.end(), focused) != m_textTransPlural.end();
}


void EditingArea::CopyFromSingular()
{
    auto current = dynamic_cast<TranslationTextCtrl*>(wxWindow::FindFocus());
    if (!current || !m_textTransSingularForm)
        return;

    current->SetPlainTextUserWritten(m_textTransSingularForm->GetPlainText());
}


void EditingArea::UpdateToTextCtrl(CatalogItemPtr item, int flags)
{
    auto syntax = SyntaxHighlighter::ForItem(*item);
    m_textOrig->SetSyntaxHighlighter(syntax);
    if (m_textTrans)
        m_textTrans->SetSyntaxHighlighter(syntax);
    if (item->HasPlural())
    {
        m_textOrigPlural->SetSyntaxHighlighter(syntax);
        for (auto p : m_textTransPlural)
            p->SetSyntaxHighlighter(syntax);
    }

    m_textOrig->SetPlainText(item->GetString());

    if (item->HasPlural())
    {
        m_textOrigPlural->SetPlainText(item->GetPluralString());

        unsigned formsCnt = (unsigned)m_textTransPlural.size();
        for (unsigned j = 0; j < formsCnt; j++)
            SetTranslationValue(m_textTransPlural[j], wxEmptyString, flags);

        unsigned i = 0;
        for (i = 0; i < std::min(formsCnt, item->GetNumberOfTranslations()); i++)
        {
            SetTranslationValue(m_textTransPlural[i], item->GetTranslation(i), flags);
        }
    }
    else
    {
        if (m_textTrans)
            SetTranslationValue(m_textTrans, item->GetTranslation(), flags);
    }

    if (item->HasContext())
    {
        const wxString prefix = _("Context:");
        const wxString ctxt = item->GetContext();
        m_labelContext->SetLabelMarkup(
            wxString::Format("<b>%s</b> %s", prefix, EscapeMarkup(ctxt)));
    }
    m_labelContext->GetContainingSizer()->Show(m_labelContext, item->HasContext());

    if (m_errorBar)
    {
        if (item->GetValidity() == CatalogItem::Val_Invalid)
            m_errorBar->ShowError(item->GetErrorString());
        else
            m_errorBar->HideError();
    }

    ShowPluralFormUI(item->HasPlural());

    // by default, editing fuzzy item unfuzzies it
    m_dontAutoclearFuzzyStatus = false;
}


void EditingArea::UpdateFromTextCtrl()
{
    auto item = m_associatedList->GetCurrentCatalogItem();
    if (!item)
        return;

    wxString key = item->GetString();
    bool newfuzzy = m_associatedToolbar->IsFuzzy();

    const bool oldIsTranslated = item->IsTranslated();
    bool allTranslated = true; // will be updated later
    bool anyTransChanged = false; // ditto

    if (item->HasPlural())
    {
        wxArrayString str;
        for (unsigned i = 0; i < m_textTransPlural.size(); i++)
        {
            auto val = PreprocessEnteredTextForItem(item, m_textTransPlural[i]->GetPlainText());
            str.Add(val);
            if ( val.empty() )
                allTranslated = false;
        }

        if ( str != item->GetTranslations() )
        {
            anyTransChanged = true;
            item->SetTranslations(str);
        }
    }
    else
    {
        auto newval = PreprocessEnteredTextForItem(item, m_textTrans->GetPlainText());

        if ( newval.empty() )
            allTranslated = false;

        if ( newval != item->GetTranslation() )
        {
            anyTransChanged = true;
            item->SetTranslation(newval);
        }
    }

    if (item->IsFuzzy() == newfuzzy && !anyTransChanged)
    {
        return; // not even fuzzy status changed, so return
    }

    // did something affecting statistics change?
    bool statisticsChanged = false;

    if (newfuzzy == item->IsFuzzy() && !m_dontAutoclearFuzzyStatus)
        newfuzzy = false;

    m_associatedToolbar->SetFuzzy(newfuzzy);

    if ( item->IsFuzzy() != newfuzzy )
    {
        item->SetFuzzy(newfuzzy);
        statisticsChanged = true;
    }
    if ( oldIsTranslated != allTranslated )
    {
        item->SetTranslated(allTranslated);
        statisticsChanged = true;
    }
    item->SetModified(true);
    item->SetPreTranslated(false);

    m_associatedList->RefreshSelectedItems();

    if (OnUpdatedFromTextCtrl)
        OnUpdatedFromTextCtrl(item, statisticsChanged);
}


void EditingArea::ChangeFocusedPluralTab(int offset)
{
    wxCHECK_RET(offset == +1 || offset == -1, "invalid offset");

    m_pluralNotebook->AdvanceSelection(/*forward=*/offset == +1 ? true : false);
    m_textTransPlural[m_pluralNotebook->GetSelection()]->SetFocus();
}
